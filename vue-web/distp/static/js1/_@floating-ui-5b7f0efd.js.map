{"version":3,"file":"_@floating-ui-5b7f0efd.js","sources":["../../../node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js","../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.development.js"],"sourcesContent":["function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let _debug_loop_count_ = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    {\n      _debug_loop_count_++;\n\n      if (_debug_loop_count_ > 100) {\n        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));\n      }\n    }\n\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset) {\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]); // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside of the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    return {\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$slice$;\n\n              const placement = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0) - b.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nfunction convertValueToCoords(placement, rects, value, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value({ ...rects,\n    placement\n  }) : value;\n  const isNumber = typeof rawValue === 'number'; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = isNumber ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const diffCoords = convertValueToCoords(placement, rects, value, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        height: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        width: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...dimensions,\n        ...rects\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(navigator.userAgent); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child == null ? void 0 : child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent != null && parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize: _elementResize = true,\n    animationFrame = false\n  } = options;\n  let cleanedUp = false;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const elementResize = _elementResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    observer = new ResizeObserver(update);\n    isElement(reference) && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    if (cleanedUp) {\n      return;\n    }\n\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  return () => {\n    var _observer;\n\n    cleanedUp = true;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n"],"names":["computePosition","min","max","min$1","max$1"],"mappings":"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"}